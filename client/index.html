<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Slither 3D Multiplayer</title>
  <style>
    body {margin:0; overflow:hidden;}
    canvas {display:block;}
    #score, #length, #players, #timer {
      position:absolute; color:white; font-size:20px;
    }
    #score {top:10px; left:10px;}
    #length {top:40px; left:10px;}
    #players {top:70px; left:10px;}
    #timer {top:100px; left:10px;}
    #overlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.8); color:white;
      display:flex; justify-content:center; align-items:center;
      flex-direction:column; font-size:30px; cursor:pointer;
    }
  </style>
</head>
<body>

  <div id="score">Score: 0</div>
  <div id="length">Length: 6</div>
  <div id="players">Players: 1</div>
  <div id="timer">Time: 0s</div>
  <div id="ranking" style="top:130px; left:10px; position:absolute; color:white;"></div>
  <div id="overlay">
    <div>Slither 3D</div>
    <input id="nameInput" placeholder="Tu nombre" style="font-size:20px; margin:10px;">
    <button style="font-size:20px;">Empezar</button>
  </div>



<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
  // ---------- ESCENA ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ---------- JUGADOR ----------
  const playerGeom = new THREE.SphereGeometry(0.5,16,16);
  const playerMat = new THREE.MeshBasicMaterial({color:0x00ff00});
  const player = new THREE.Mesh(playerGeom, playerMat);
  scene.add(player);

  const segments = [];
  let wormMesh = null;
  let wormGeometry = null;

  for(let i=0;i<5;i++){
    const geom = new THREE.SphereGeometry(0.4,16,16);
    const mat = new THREE.MeshBasicMaterial({color:0x00ff00});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.copy(player.position);
    scene.add(mesh);
    segments.push(mesh);
  }

  const light = new THREE.DirectionalLight(0xffffff, 0.8);
  light.position.set(5,10,5);
  scene.add(light);

  const grid = new THREE.GridHelper(100,100);
  scene.add(grid);

  camera.position.y = 5;
  camera.position.z = 5;

  // ---------- MOUSE ----------
  let mouse = {x:0,y:0};
  window.addEventListener("mousemove", e=>{
    mouse.x = (e.clientX/window.innerWidth)*2-1;
    mouse.y = -(e.clientY/window.innerHeight)*2+1;
  });

  // ---------- RAYCASTER ----------
  const raycaster = new THREE.Raycaster();
  const planeY = new THREE.Plane(new THREE.Vector3(0,1,0),0);
  function getMouseWorld(){
    raycaster.setFromCamera(mouse, camera);
    const inter = new THREE.Vector3();
    raycaster.ray.intersectPlane(planeY, inter);
    return inter;
  }

  // ---------- WEBSOCKET ----------
  const socket = new WebSocket("wss://triumphantly-unpublic-brooklyn.ngrok-free.dev");
  const otherPlayers = {};
  let playerName = "none";
  const myId = Date.now() + Math.random();
  const rankingDiv = document.getElementById("ranking");


  socket.onmessage = event => {
    const data = JSON.parse(event.data);

    // -------- RANKING --------
    if(data.ranking){
      rankingDiv.innerHTML = "<b>Ranking</b><br>";
      data.ranking.forEach((p,i)=>{
        rankingDiv.innerHTML += `${i+1}. ${p.name}: ${p.score}<br>`;
      });
    }

    // -------- OTROS JUGADORES --------
    for(let id in data.players){
      if(id == myId) continue;

      const p = data.players[id].body;
      if(!p || p.length === 0) continue;

      if(!otherPlayers[id]){
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(0.5,16,16),
          new THREE.MeshBasicMaterial({color:0xff0000})
        );
        scene.add(mesh);

        const segs = [];
        for(let i=1;i<p.length;i++){
          const s = new THREE.Mesh(
            new THREE.SphereGeometry(0.4,16,16),
            new THREE.MeshBasicMaterial({color:0xff0000})
          );
          scene.add(s);
          segs.push(s);
        }

        otherPlayers[id] = {mesh,segs};
      }

      otherPlayers[id].mesh.position.set(p[0].x,p[0].y,p[0].z);
      otherPlayers[id].mesh.rotation.y = p[0].rotationY;

      for(let i=1;i<p.length;i++){
        otherPlayers[id].segs[i-1].position.lerp(
          new THREE.Vector3(p[i].x,p[i].y,p[i].z), 0.3
        );
      }
    }
  };


  function sendPositions(){
    if(socket.readyState !== WebSocket.OPEN) return;
    const data = [];
    data.push({x:player.position.x, y:player.position.y, z:player.position.z, rotationY:player.rotation.y, score});
    for(let i=0;i<segments.length;i++){
        data.push({x:segments[i].position.x, y:segments[i].position.y, z:segments[i].position.z});
    }
    socket.send(JSON.stringify(data));
    }
    setInterval(sendPositions, 50);

  // ---------- COMIDA ----------
  const foodItems = [];
  function spawnFood(special=false){
    const geom = new THREE.SphereGeometry(special?0.5:0.3,8,8);
    const mat = new THREE.MeshBasicMaterial({color:special?0xff00ff:0xffff00});
    const mesh = new THREE.Mesh(geom, mat);

    mesh.userData.special = special; // MARCA SI ES ESPECIAL

    mesh.position.set((Math.random()-0.5)*50,0,(Math.random()-0.5)*50);
    scene.add(mesh);
    foodItems.push(mesh);
  }


  for(let i=0;i<20;i++) spawnFood();
  setInterval(()=>spawnFood(true),10000); // comida especial cada 10s

  // ---------- POWER-UPS ----------
  const powerUps = [];
  let speedBoost = false;
  let invincible = false;

  function spawnPowerUp(){
    const geom = new THREE.BoxGeometry(0.5,0.5,0.5);
    const mat = new THREE.MeshBasicMaterial({color:0x00ffff});
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.set((Math.random()-0.5)*50,0,(Math.random()-0.5)*50);
    scene.add(mesh);
    powerUps.push(mesh);
  }
  setInterval(spawnPowerUp,15000); // cada 15s

  // ---------- UI ----------
  const scoreDiv = document.getElementById("score");
  const lengthDiv = document.getElementById("length");
  const playersDiv = document.getElementById("players");
  const timerDiv = document.getElementById("timer");
  const overlay = document.getElementById("overlay");

  let gameStarted = false;

  overlay.querySelector("button").addEventListener("click",()=>{
    const input = document.getElementById("nameInput");
    playerName = input.value || "Anon";

    overlay.style.display = "none";
    overlay.querySelector("button").innerText = "Reaparecer";

    socket.send(JSON.stringify({
      type: "init",
      id: myId,
      name: playerName
    }));

    startGame();
  });

  function dropFoodFromWorm(){
    // comida por cada segmento
    for(let s of segments){
      const geom = new THREE.SphereGeometry(0.3,8,8);
      const mat = new THREE.MeshBasicMaterial({color:0xffff00});
      const food = new THREE.Mesh(geom, mat);

      food.userData.special = false;

      food.position.copy(s.position);
      scene.add(food);
      foodItems.push(food);
    }

    // comida extra en la cabeza
    for(let i=0;i<3;i++){
      spawnFood(true); // un poco de comida especial
    }
  }


  function resetWorm(){
    // borrar tubo
    if(wormMesh){
      scene.remove(wormMesh);
      wormGeometry.dispose();
      wormMesh = null;
    }

    // borrar segmentos
    segments.forEach(s => scene.remove(s));
    segments.length = 0;

    // recrear cuerpo inicial
    for(let i=0;i<5;i++){
      const geom = new THREE.SphereGeometry(0.4,16,16);
      const mat = new THREE.MeshBasicMaterial({color:0x00ff00});
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(player.position);
      mesh.visible = false;
      scene.add(mesh);
      segments.push(mesh);
    }
  }

  function killPlayer(){
    dropFoodFromWorm();
    resetWorm();
    resetPlayer();
  }

  function startGame(){
    gameStarted = true;
    startTime = Date.now();
    score = 0;

    player.position.set(
      (Math.random()-0.5)*50,
      0,
      (Math.random()-0.5)*50
    );

    resetWorm();

    invincible = true;
    setTimeout(() => invincible = false, 2000);

  }




  // ---------- ANIMACIÓN ----------
  let score = 0;
  let highScore = 0;
  const baseSpeed = 0.15;
  const target = new THREE.Vector3();
  const boundary = 25;
  let startTime = Date.now();

  function updateWormMesh(){
    const points = [];

    // cabeza
    points.push(player.position.clone());

    // cuerpo
    for(let s of segments){
      points.push(s.position.clone());
    }

    if(points.length < 2) return;

    const curve = new THREE.CatmullRomCurve3(points);

    if(wormMesh){
      scene.remove(wormMesh);
      wormGeometry.dispose();
    }

    wormGeometry = new THREE.TubeGeometry(
      curve,
      64,     // suavidad
      0.35,   // grosor
      8,
      false
    );

    const material = new THREE.MeshStandardMaterial({
      color: 0x00ff00
    });

    wormMesh = new THREE.Mesh(wormGeometry, material);
    scene.add(wormMesh);
  }

  player.visible = false;
  segments.forEach(s => s.visible = false);


  function animate(){
    requestAnimationFrame(animate);
    if(!gameStarted) return;

    // mover jugador hacia mouse
    target.copy(getMouseWorld());
    let dir = new THREE.Vector3().subVectors(target, player.position);
    const dist = dir.length();
    if(dist>0.05){
      dir.normalize();
      let moveSpeed = baseSpeed;
      if(speedBoost) moveSpeed *= 2;
      player.position.addScaledVector(dir, Math.min(moveSpeed, dist));
      player.rotation.y += (Math.atan2(dir.x, dir.z)-player.rotation.y)*0.1;
    }

    // Limites del terreno
    player.position.x = Math.max(-boundary, Math.min(boundary, player.position.x));
    player.position.z = Math.max(-boundary, Math.min(boundary, player.position.z));

    // mover segmentos
    for(let i=segments.length-1;i>0;i--){
      segments[i].position.lerp(segments[i-1].position,0.2);
    }
    segments[0].position.lerp(player.position,0.2);
    updateWormMesh();


    // actualizar cámara
    const camOffset = new THREE.Vector3(0,3,-5);
    const rotOffset = camOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0),player.rotation.y);
    camera.position.copy(player.position).add(rotOffset);
    camera.lookAt(player.position);

    // colisiones con comida
    for(let i = foodItems.length - 1; i >= 0; i--){
      const food = foodItems[i];

      if(player.position.distanceTo(food.position) < 0.6){
        const isSpecial = food.userData.special;

        scene.remove(food);
        foodItems.splice(i, 1);

        // crecer gusano
        const geom = new THREE.SphereGeometry(0.4,16,16);
        const mat = new THREE.MeshBasicMaterial({color:0x00ff00});
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.copy(segments[segments.length - 1].position);
        scene.add(mesh);
        segments.push(mesh);

        // puntos
        score += isSpecial ? 5 : 1;
        scoreDiv.innerText = `Score: ${score}`;

        spawnFood();
      }
    }


    // colisiones con power-ups
    for(let i=powerUps.length-1;i>=0;i--){
      if(player.position.distanceTo(powerUps[i].position)<0.6){
        scene.remove(powerUps[i]);
        powerUps.splice(i,1);
        if(Math.random()<0.5){
          speedBoost = true;
          setTimeout(()=> speedBoost=false,5000);
        }else{
          invincible = true;
          setTimeout(()=> invincible=false,5000);
        }
      }
    }

    // colisiones con otros jugadores (muerte instantánea)
    for(let id in otherPlayers){
      const other = otherPlayers[id];

      // cabeza vs cabeza
      if(player.position.distanceTo(other.mesh.position) < 0.5 && !invincible){
        killPlayer();
        return;
      }

      // cabeza vs cuerpo
      for(let i=0;i<other.segs.length;i++){
        if(player.position.distanceTo(other.segs[i].position) < 0.5 && !invincible){
          killPlayer();
          return;
        }
      }
    }



    // actualizar UI
    lengthDiv.innerText = `Length: ${segments.length+1}`;
    playersDiv.innerText = `Players: ${Object.keys(otherPlayers).length+1}`;
    timerDiv.innerText = `Time: ${Math.floor((Date.now()-startTime)/1000)}s`;

    renderer.render(scene, camera);
  }

  function resetPlayer(){
    gameStarted = false;
    overlay.style.display = "flex";
  }



  animate();

  window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
